{{> menu active="dashboard"}}
<br>


<section class="content section background-is-black">
  <div class="box columns is-centered">


    <div class="column is-half">

      <div style="text-align: center">
        <h2>Speed</h2>
        <h3 id="actualSpeed">0</h3>
        <canvas class="column is-full" id='gauge1'></canvas>
      </div>
    </div>

    <div class="column is-half">
      <div style="text-align: center">
        <h2>RPM</h2>
        <h3 id="actualRpm">0</h3>
        <canvas class="column is-full" id='gauge2'></canvas>
      </div>
    </div>
  </div>

  <div class="box">
    <h1>
      Current Location
    </h1>
    <div class="" style="height: 45vh" id="currentlocationmap">
    </div>
  </div>

  <div class="box">
    <h1>
      Trips starting locations
    </h1>
    <div class="" style="height: 45vh" id="map1">
    </div>
  </div>
  {{> list-trips}}
  <div class="box">
    {{> record-button}}
  </div>


</section>
<script>
  ///TRIPS LOCATION MAPS
  const map = L.map('map1').setView([50, 10], 5);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  }).addTo(map);
</script>

<script>
  ///CURRENT LOCATION MAP
  const currentlocationmap = L.map('currentlocationmap').setView([45, 20], 5);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  }).addTo(currentlocationmap);
</script>

{{#each trips}}
<script>
  L.marker([{{ startingLocationLatitude }}, {{ startingLocationLongitude }}]).addTo(map)
    .bindPopup('{{_id}}');
</script>
{{/each}}

<script src="https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"></script>
<script> src = "/scripts/speedGauge.js"</script>

<script type ="module">
  ///GAUGES SCRIPT + LIVE ASSIGNMENT OF DATA
  let speedFromMqtt
  let rpmFromMqtt
  let latFromMqtt
  let lonFromMqtt

  const opts1 = {
    angle: -0.21, // The span of the gauge arc
    lineWidth: 0.15, // The line thickness
    radiusScale: 0.78, // Relative radius
    pointer: {
      length: 0.42, // // Relative to gauge radius
      strokeWidth: 0.033, // The thickness
      color: '#000000' // Fill color
    },
    limitMax: false,     // If false, max value increases automatically if value > maxValue
    limitMin: false,     // If true, the min value of the gauge will be fixed
    colorStart: '#6F6EA0',   // Colors
    colorStop: '#C0C0DB',    // just experiment with them
    strokeColor: '#EEEEEE',  // to see which ones work best for you
    generateGradient: true,
    highDpiSupport: true,     // High resolution support

  };
  let speed = speedFromMqtt || 0
  let rpm = rpmFromMqtt || 0
  let target1 = document.getElementById('gauge1'); // your canvas element
  const gauge1 = new Gauge(target1).setOptions(opts1); // create sexy gauge!
  gauge1.maxValue = 360;
  gauge1.setMinValue(10);  // Prefer setter over gauge.minValue = 0
  gauge1.animationSpeed = 45; // set animation speed (32 is default value)
  gauge1.set(speed); // set actual value

  src = "https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"
  const opts2 = {
    angle: -0.21, // The span of the gauge arc
    lineWidth: 0.15, // The line thickness
    radiusScale: 0.78, // Relative radius
    pointer: {
      length: 0.42, // // Relative to gauge radius
      strokeWidth: 0.033, // The thickness
      color: '#000000' // Fill color
    },
    limitMax: false,     // If false, max value increases automatically if value > maxValue
    limitMin: false,     // If true, the min value of the gauge will be fixed
    colorStart: '#6F6EA0',   // Colors
    colorStop: '#C0C0DB',    // just experiment with them
    strokeColor: '#EEEEEE',  // to see which ones work best for you
    generateGradient: true,
    highDpiSupport: true,     // High resolution support

  };
  let target2 = document.getElementById('gauge2'); // your canvas element
  const gauge2 = new Gauge(target2).setOptions(opts2);
  gauge2.maxValue = 5000;
  gauge2.setMinValue(10);  // Prefer setter over gauge.minValue = 0
  gauge2.animationSpeed = 45; // set animation speed (32 is default value)
  ; // set actual value


  const ws = new WebSocket("ws://localhost:8080"); // match the server port

  ws.addEventListener("open", () => {
    console.log("Connected with mqttWSside");
  });

  ws.addEventListener("message", event => {
    console.log("Message from server:", event.data);
    console.log(JSON.parse(event.data))
    speedFromMqtt = JSON.parse(event.data).speed
    rpmFromMqtt = JSON.parse(event.data).rpm
    latFromMqtt = JSON.parse(event.data).latitude
    lonFromMqtt = JSON.parse(event.data).longitude

  });

  ws.addEventListener("error", err => {
    console.error("WebSocket error:", err);
  })
  let marker = null;
  setInterval(function () {
    rpmFromMqtt ??= 0 //avoid undefined text
    speedFromMqtt ??= 0
    latFromMqtt ??= 0
    lonFromMqtt ??= 0
    document.getElementById("actualSpeed").innerHTML = speedFromMqtt
    document.getElementById("actualRpm").innerHTML = rpmFromMqtt
    gauge2.set(rpmFromMqtt)
    gauge1.set(speedFromMqtt)
  
    currentlocationmap.setView([latFromMqtt, lonFromMqtt], 17)
    if (!marker) {
      marker = L.marker([latFromMqtt, lonFromMqtt]).addTo(currentlocationmap);
    } else {
      marker.setLatLng([latFromMqtt, lonFromMqtt]); //built-in leaflet function
    }
  }, 1500);


</script>